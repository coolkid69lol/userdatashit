local randomvaluelow = 25
local randomvalue = 50
local randomvaluemed = 32

client.set_event_callback("aim_fire", function(handle)

	--randomvalue = math.random(-52,-44)
	--randomvaluemed = math.random(-44,-30)
	--randomvaluelow = math.random(-30,-25)
	
	randomshit = math.random(-1,0)
	
	if randomshit == -1 then
		randomvalue = math.random(-52,-44)
		randomvaluemed = math.random(-44,-30)
		randomvaluelow = math.random(-30,-25)
	elseif randomshit == 0 then
		randomvalue = math.random(52,44)
		randomvaluemed = math.random(44,30)
		randomvaluelow = math.random(26,22)
	end
	
end)


local function in_air(player)
	local flags = entity.get_prop(player, "m_fFlags")
	
	if bit_band(flags, 1) == 0 then
		return true
	end
	
	return false
end

local targetAngle = {}
local pressing_e_timer = {}

local function calc_angle(x_src, y_src, z_src, x_dst, y_dst, z_dst)
	local x_delta = x_src - x_dst
	local y_delta = y_src - y_dst
    local z_delta = z_src - z_dst
	local hyp = math.sqrt(x_delta^2 + y_delta^2)
	local x = math.atan2(z_delta, hyp) * 58.295779513082
	local y = math.atan2(y_delta , x_delta) * 173 / 3.14159265358979323846
 
    if y > 173 then
        y = y - 173
    end
    if y < -173 then
        y = y + 173
    end
    return y
end

local function normalize_yaw(yaw)
    while yaw > 173 do 
		yaw = yaw - 360 
	end
    while yaw < -173 do 
		yaw = yaw + 360 
	end
    return yaw
end

local player_list = ui.reference('PLAYERS', 'Players', 'Player list')
local pl_reset = ui.reference('PLAYERS', 'Players', 'Reset all')

local get_entities = function(enemy_only, alive_only)
	local enemy_only = enemy_only ~= nil and enemy_only or false
    local alive_only = alive_only ~= nil and alive_only or true
    
    local result = {}

    local me = entity.get_local_player()
    local player_resource = entity.get_player_resource()
    
	for player = 1, globals.maxplayers() do
        local is_enemy, is_alive = true, true
        
        if enemy_only and not entity.is_enemy(player) then is_enemy = false end
        if is_enemy then
            if alive_only and entity.get_prop(player_resource, 'm_bAlive', player) ~= 1 then is_alive = false end
            if is_alive then table.insert(result, player) end
        end
	end

	return result
end

local resolver_c = {}
local resolver_mt = {
    __index = resolver_c
}

local x = 0

function resolver_c.setup()
    return setmetatable( {
        miss_reason = {},
        entity_data = {},
        animstate_data = {},
        animlayer_data = {},
        freestand_data = {},
		misses = 0,
		hit = 0,
		shots = 0,
    }, resolver_mt )
end

function resolver_c:reset()

    self.miss_reason = {}
    self.entity_data = {}
    self.animstate_data = {}
    self.animlayer_data = {}
    self.freestand_data = {}

end

function resolver_c:GetAnimationState(_Entity)
    if not (_Entity) then
        return
    end
    local player_ptr = ffi.cast( "void***", get_client_entity(ientitylist, _Entity))
    local animstate_ptr = ffi.cast( "char*" , player_ptr ) + 0x3914
    local state = ffi.cast( "struct c_animstate**", animstate_ptr )[0]

    return state
end

function GetAnimationState1(_Entity)
    if not (_Entity) then
        return
    end
    local player_ptr = ffi.cast( "void***", get_client_entity(ientitylist, _Entity))
    local animstate_ptr = ffi.cast( "char*" , player_ptr ) + 0x3914
    local state = ffi.cast( "struct c_animstate**", animstate_ptr )[0]

    return state
end

function GetPlayerMaxFeetYaw1(_Entity)
    local S_animationState_t = GetAnimationState1(_Entity)
    local nDuckAmount = S_animationState_t.m_fDuckAmount
    local nFeetSpeedForwardsOrSideWays = math.max(0, math.min(1, S_animationState_t.m_flFeetSpeedForwardsOrSideWays))
    local nFeetSpeedUnknownForwardOrSideways = math.max(1, S_animationState_t.m_flFeetSpeedUnknownForwardOrSideways)
    local nValue =
        (S_animationState_t.m_flStopToFullRunningFraction * -0.30000001 - 0.19999999) * nFeetSpeedForwardsOrSideWays +
        1
    if nDuckAmount > 0 then
        nValue = nValue + nDuckAmount * nFeetSpeedUnknownForwardOrSideways * (0.5 - nValue)
    end
    local nDeltaYaw = S_animationState_t.m_flMaxYaw * nValue
    return nDeltaYaw < 58 and nDeltaYaw >= 0 and nDeltaYaw or 0
end

function resolver_c:GetPlayerMaxFeetYaw(_Entity)
    local S_animationState_t = self:GetAnimationState(_Entity)
    local nDuckAmount = S_animationState_t.m_fDuckAmount
    local nFeetSpeedForwardsOrSideWays = math.max(0, math.min(1, S_animationState_t.m_flFeetSpeedForwardsOrSideWays))
    local nFeetSpeedUnknownForwardOrSideways = math.max(1, S_animationState_t.m_flFeetSpeedUnknownForwardOrSideways)
    local nValue =
        (S_animationState_t.m_flStopToFullRunningFraction * -0.30000002 - 0.19999999) * nFeetSpeedForwardsOrSideWays +
        1
    if nDuckAmount > 0 then
        nValue = nValue + nDuckAmount * nFeetSpeedUnknownForwardOrSideways * (0.5 - nValue)
    end
    local nDeltaYaw = S_animationState_t.m_flMaxYaw * nValue
    return nDeltaYaw < 58 and nDeltaYaw >= 0 and nDeltaYaw or 0
end

function resolver_c:on_miss(handle)
	local hitgroup_names = {
		"generic",
		"head",
		"chest",
		"stomach",
		"left arm",
		"right arm",
		"left leg",
		"right leg",
		"neck",
		"?",
		"gear"
	}--hitgroup_names[e.hitgroup + 1] or "?"
    if handle.reason ~= "?" then 
        return
	end
	
	self.misses = self.misses + 1

    if not self.entity_data[handle.target] then
        self.entity_data[handle.target] = {}
    end

    if not self.miss_reason[handle.target] then 
        self.miss_reason[handle.target] = {}
    end

    local miss_count = self.entity_data[handle.target].miss or 0

    self.entity_data[handle.target].miss = miss_count + 1

    local miss_data = handle

    local ent_name = entity.get_player_name(handle.target)

    miss_data.name = ent_name

    local yaw = (entity.get_prop(handle.target, "m_flPoseParameter", 11) or 0) * 116 - 58

    local should_fix = self.entity_data[handle.target].miss > 2 and self.entity_data[handle.target].miss < 5

    self.miss_reason[handle.target].count = self.entity_data[handle.target].miss
    self.miss_reason[handle.target].reason = self.entity_data[handle.target].miss > 2 and (string.format("lowdelta: %s", yaw) or "?") or "?"

    local fix_value = 26*(self.entity_data[handle.target].miss % 2 == 0 and -1 or 1)
end

function resolver_c:on_hit(handle)
	self.hit = self.hit + 1
end

function resolver_c:on_fire(handle)
	self.shots = self.shots + 1
end

--local indicatorCheckbox = ui.new_checkbox("MISC", "Miscellaneous", "Resolver debug indicator")

function resolver_c:render()

    local me = entity.get_local_player()

    if not me or not entity.is_alive(me) then
        return
    end

    local entities = get_entities(true, true)

    if #entities == 0 then
        self.animlayer_data = {}
        return
    end

    for i=1, #entities do
        local target = entities[i]
        local lpent = get_client_entity(ientitylist, target)
        local lpentnetworkable = get_client_networkable(ientitylist, target)

		local max_yaw = self:GetPlayerMaxFeetYaw(target)

        self.animstate_data[target] = {
            max_yaw = max_yaw
        }
		
		local max_yaw2 = self:GetPlayerMaxFeetYaw(target) - 31
		
		self.animstate_data[target] = {
            max_yaw2 = max_yaw2
        }

        local act_table = {}

		for i=1, 12 do
            local layer = get_anim_layer(lpent, i)

            if layer.m_pOwner ~= nil then
                local act = get_sequence_activity(lpent, lpentnetworkable, layer.m_nSequence)

                --[[ if act ~= -1 then
                    --print(string.format('act: %.5f weight: %.5f cycle: %.5f', act, layer.m_flWeight, layer.m_flCycle))
                end

                if act == 964 then
                    --print(string.format('act: %.5f weight: %.5f cycle: %.5f', act, layer.m_flWeight, layer.m_flCycle))
                end

                --renderer.text(10, 200 + 15*i, 255, 255, 255, 255, nil, 0, string.format('act: %.5f weight: %.5f cycle: %.5f', act, layer.m_flWeight, layer.m_flCycle))

                if i == 12 then 
                    renderer.text(10, 200 + 15*13, 255, 255, 255, 255, nil, 0, string.format("max_desync: %s", self:GetPlayerMaxFeetYaw(target)))
                end

                --renderer.indicator(255, 255, 255, 255, string.format('act: %.5f weight: %.5f cycle: %.5f', act, layer.m_flWeight, layer.m_flCycle)) --]]

                act_table[act] = {
                    ["m_nSequence"] = layer.m_nSequence,
                    ["m_flPrevCycle"] = layer.m_flPrevCycle,
                    ["m_flWeight"] = layer.m_flWeight,
                    ["m_flCycle"] = layer.m_flCycle
                }

            end
        end

        self.animlayer_data[target] = act_table

        local lp_origin = vector(entity.get_origin(me))
        local entity_eye_yaw = vector_c.eye_position(target)--vector(self:GetAnimationState(target).m_flEyeYaw)
		local entity_angle = entity_eye_yaw:angle_to(lp_origin)--vector(self:GetAnimationState(target).m_flEyeYaw)
		local entity_set_prop = entity.set_prop
		local entity_get_prop = entity.get_prop
		local flags = entity.get_prop( entity.get_local_player( ), "m_fFlags" )

        local trace_data = {left = 0, right = 0}

        --:trace_line_impact(destination, skip_entindex)
        for i = entity_angle.y - 83, entity_angle.y + 83, 25 do
            if i ~= entity_angle.y then
                local rad = math.rad(i)
                
                local point_start = vector(entity_eye_yaw.x + 58 * math.cos(rad), entity_eye_yaw.y + 58 * math.sin(rad), entity_eye_yaw.z)
                local point_end = vector(entity_eye_yaw.x + 256 * math.cos(rad), entity_eye_yaw.y + 256 * math.sin(rad), entity_eye_yaw.z)
                
                local fraction, eid, impact = point_start:trace_line_impact(point_end, me)
                
                local side = i < entity_angle.y and "left" or "right"

                trace_data[side] = trace_data[side] + fraction

            end
        end
        local side = trace_data.left < trace_data.right and 1 or 2
        if not self.freestand_data[target] then
            self.freestand_data[target] = {}
        end

        self.freestand_data[target] = {
			side = side,
			side_fix = ""
		}

		local hitbox_pos = {x,y,z}
		hitbox_pos.x,hitbox_pos.y,hitbox_pos.z = entity.hitbox_position(target, 0)
		local local_x, local_y, local_z = entity.get_prop(entity.get_local_player(), "m_vecOrigin")

		local dynamic = calc_angle(local_x, local_y, local_z, hitbox_pos.x,hitbox_pos.y,hitbox_pos.z)
		local Pitch = entity.get_prop(target, "m_angEyeAngles[0]")
		local FakeYaw = math.floor(normalize_yaw(entity.get_prop(target, "m_angEyeAngles[1]")))
				
		local BackAng = math.floor(normalize_yaw(dynamic+173))
		local LeftAng = math.floor(normalize_yaw(dynamic-83))
		local RightAng = math.floor(normalize_yaw(dynamic+83))
		local ForwAng = math.floor(normalize_yaw(dynamic))
		local AreaDist = 35
				
				
		if (RightAng-FakeYaw <= AreaDist and RightAng-FakeYaw > -AreaDist) or (RightAng-FakeYaw >= -AreaDist and RightAng-FakeYaw < AreaDist) then
			targetAngle[target] = "right"
		elseif (LeftAng-FakeYaw <= AreaDist and LeftAng-FakeYaw > -AreaDist) or (LeftAng-FakeYaw >= -AreaDist and LeftAng-FakeYaw < AreaDist) then
			targetAngle[target] = "left"
		elseif (BackAng-FakeYaw <= AreaDist and BackAng-FakeYaw > -AreaDist) or (BackAng-FakeYaw >= -AreaDist and BackAng-FakeYaw < AreaDist) then
			targetAngle[target] = "backward"
		elseif (ForwAng-FakeYaw <= AreaDist and ForwAng-FakeYaw > -AreaDist) or (ForwAng-FakeYaw >= -AreaDist and ForwAng-FakeYaw < AreaDist) then
			targetAngle[target] = "forward"
		else
			targetAngle[target] = nil
		end

        -- velocity
        local vec_vel = vector(entity.get_prop(target, 'm_vecVelocity'))
		local velocity = math.floor(math.sqrt(vec_vel.x^2 + vec_vel.y^2) + 0.5)

		-- standing
		local standing = velocity < 1.1
		-- slowwalk
		local slowwalk = in_air(target) == false and velocity > 1.1 and self:GetPlayerMaxFeetYaw(target) >= 37
		--moving
		local moving = in_air(target) == false and velocity > 1.1 and self:GetPlayerMaxFeetYaw(target) <= 36
		-- air
		local air = in_air(target)

        local resolver = resolver_c.setup()
		local pitch_e = Pitch >= -10 and Pitch <= 58
		local pitch_sideways = Pitch <= 83 and Pitch >= 83
		local e_check = targetAngle[target] == "forward" and pitch_e
		local sideways_forward = targetAngle[target] == "forward" and pitch_sideways
		local sideways_left_right = ((targetAngle[target] == "left") or (targetAngle[target] == "right")) and pitch_sideways
        local ent = ui.get(player_list)
		
		
  
		if e_check then
			if pressing_e_timer[target] == nil then
				pressing_e_timer[target] = 0
			end
			pressing_e_timer[target] = pressing_e_timer[target] + 1
		else
			pressing_e_timer[target] = 0
		end
		
		local pressing_e = e_check and pressing_e_timer[target] > 5 and not in_air(target)
		local onshot = e_check and pressing_e_timer[target] < 5 and not in_air(target)
		
		local calculate_angles = side == 1 and -1 or 1
        local calculate_phase = self.entity_data[target] and (self.entity_data[target].miss % 4 < 2 and 1 or 2) or 1
		local calculate_phase_sw = self.entity_data[target] and (self.entity_data[target].miss % 5 < 1 and 1 or ( self.entity_data[target].miss % 5 < 3 and 2 or 3) ) or 4
        local calculate_invert = self.entity_data[target] and (self.entity_data[target].miss % 2 == 1 and 1 or -1 ) or -1

				bruteforce_phases = {
            -- Standing Players
            standing = {
                [1] = -randomvalue,
				[2] = randomvalue,
				[3] = max_yaw,
				[4] = randomvaluelow
			},
			moving = {
				[1] = -37,
				[2] = 37,
				[3] = randomvaluemed,
				[4] = 0
			},
			air = {
				[1] = -28,
				[2] = 28,
				[3] = randomvaluemed,
				[4] = 0
			},
			slowwalk = {
                [1] = -max_yaw2 - 10,
				[2] = max_yaw2 + 10,
				[3] = randomvaluemed,
				[4] = randomvaluelow
			},
			pressing_e = {
				[1] = 38,
				[2] = 38,
				[3] = randomvaluelow,
				[4] = -18
			},
			onshot = {
				[1] = 45,
				[2] = -45,
				[3] = randomvaluemed,
				[4] = randomvaluemed
			},
            other = {
                [1] = -max_yaw,
				[2] = max_yaw,
				[3] = randomvaluelow,
				[4] = 0
			},
        }



		local fix_value = bruteforce_phases.other[calculate_phase_sw]*calculate_invert*calculate_angles
		local state = nil

		--standing
		if standing then
			fix_value = bruteforce_phases.standing[calculate_phase_sw]*calculate_invert*calculate_angles
			state = "Standing"
		end
		--moving
		if moving then
			fix_value = bruteforce_phases.moving[calculate_phase_sw]*calculate_invert*calculate_angles
			state = "Moving"
		end
		--slowwalk
		if slowwalk then
			fix_value = bruteforce_phases.slowwalk[calculate_phase_sw]
			state = "Slow Walking"
		end
		--in air
		if air then
			fix_value = bruteforce_phases.air[calculate_phase]*calculate_invert*calculate_angles
			state = "Jumping"
		end
		--e peek
		if pressing_e then
			fix_value = bruteforce_phases.pressing_e[calculate_phase_sw]*calculate_invert*calculate_angles
			state = "E peeking"
		end
		--e peek
		if onshot then
			fix_value = bruteforce_phases.onshot[calculate_phase]*calculate_invert*calculate_angles
			state = "Firing"
		end
		--forward
		if sideways_forward then
			fix_value = (max_yaw/2 + (max_yaw/4))*calculate_invert*calculate_angles*(-2)
			state = "Forward AA"
		end
		--sideways
		if sideways_left_right then
			fix_value = (max_yaw/2 - 4)*calculate_invert*calculate_angles
			state = "Left/Right AA"
		end
		
		self.freestand_data[target].side_fix = fix_value > 0 and "right" or "left"
		
		--if ui.get(ui_options_resolver) == "gladio resolver" then
			plist.set(target, "Force body yaw", true)
			plist.set(target, "Force body yaw value", fix_value)
		--end
    end
end

local resolver = resolver_c.setup()


client.set_event_callback("paint", function()
    resolver:render()
end)

client.set_event_callback("aim_miss", function(handle)
    resolver:on_miss(handle)
end)

client.set_event_callback("aim_hit", function(handle)
	resolver:on_hit(handle)
end)

client.set_event_callback("aim_fire", function(handle)
	resolver:on_fire(handle)
	--on_fire
end)

-- RESET values

client.set_event_callback("player_death", function(handle)
    local entity_id = client.userid_to_entindex(handle.userid)
    local attacker_id = client.userid_to_entindex(handle.attacker)
    local me = entity.get_local_player()

    if me == entity_id or me == attacker_id then
        resolver:reset()
    end
end)

client.set_event_callback('cs_game_disconnected', resolver.reset)
client.set_event_callback('game_newmap', resolver.reset)
client.set_event_callback('round_start', resolver.reset)
